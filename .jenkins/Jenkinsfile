def arti_instance = "https://conan.jfrog.io/conan"
def credential = "c3i_on_artifactory"
def artifactory_name = "ArtifactoryConan"
def core_repo = "https://github.com/lasote/c3i_core.git"

def win_tmp_path = "D:/c3ipr"
def json_file_path = 'c3i_configs.json'
def repo_name = "c3i_${env.BRANCH_NAME}_${env.BUILD_NUMBER}".toString()
def the_json

def abortPreviousRunningBuilds() {
  def hi = Hudson.instance
  def pname = env.JOB_NAME.split('/')[0]

  hi.getItem(pname).getItem(env.JOB_BASE_NAME).getBuilds().each{ build ->
    def exec = build.getExecutor()

    if (build.number != currentBuild.number && exec != null) {
      exec.interrupt(
        Result.ABORTED,
        new CauseOfInterruption.UserInterruption(
          "Aborted by #${currentBuild.number}"
        )
      )
      println("Aborted previous running build #${build.number}")
    } else {
      println("Build is not running or is current build, not aborting - #${build.number}")
    }
  }
}


def Run(command, sudo=false, returnStatus=false){
    def ret
    if(!isUnix()){
      ret = bat script: command, returnStatus: returnStatus
    }
    else{
      if(sudo){
        command = "sudo " + command
      }
      ret = sh script: command, returnStatus: returnStatus
    }
    return ret
}

def Process(build_folder, commit, url, profile, ref, arti_instance, credential, repo_name){
    //Run("pip install virtualenv", true)
    withPythonEnv('python'){
         Run("pip install conan --upgrade")
         echo "BUILD FOLDER: ${build_folder}"
         dir(build_folder){
            if(!isUnix()){
               Run("git config --global core.autocrlf false")
            }
            checkout([$class: 'GitSCM', branches: [[name: commit ]], userRemoteConfigs: [[url: url]]])
            writeFile file: "${build_folder}/_profile.txt", text: profile
            def server = Artifactory.newServer url: arti_instance, credentialsId: credential
            def client = Artifactory.newConanClient(userHome: build_folder)
            def remoteName = client.remote.add server: server, repo: repo_name

            withEnv(["CONAN_USER_HOME=${build_folder}"]){
                def install = "conan install ${ref} -pr ${build_folder}/_profile.txt --build never -r ${remoteName}".toString()
                def ret = Run(install, false, true)
                if(ret != 0){
                    def create = "conan create ${build_folder} ${ref} -pr ${build_folder}/_profile.txt".toString()
                    ret = Run(create, false, true)
                    if(ret == 6){
                      echo "Skipping configuration!"
                    }
                    else if(ret == 0){
                      client.run(command: "remote list")
                      def b = client.run(command: "upload ${ref} -r '${remoteName}' --all -c".toString())
                      server.publishBuildInfo b
                    }
                    else{
                        throw new Exception("Conan create error ${ret}")
                    }
                }
                else{
                    echo "Skipping, binary already found in the repository!"
                }
            }
         }
    }
}

node("Linux"){
  stage("Generate builds: "){
    echo "${env.BRANCH_NAME}"
    def basedir = pwd()
    def scmVars = checkout scm
    dir(".c3_core") {
      git branch: 'master', url: core_repo
      sh(script: "./c3i/pull_request/launch.sh ${basedir} ${json_file_path}")
      the_json = readJSON file: json_file_path
    }
  }
  stage("Create Build Artifactory: ${repo_name}"){
    def server = Artifactory.server artifactory_name
    def config = "{ \"key\": \"${repo_name}\", \"rclass\": \"local\", \"packageType\": \"conan\"}"
    // TODO: Get url from arti server?
    def url = "${arti_instance}/api/repositories/${repo_name}"
    def response = httpRequest url:url, \
                               httpMode: "PUT", \
                               requestBody: config, \
                               authentication: credential, \
    						   customHeaders: [[name: "content-type", value: "application/json"]]
  }
}


the_json["stages"].eachWithIndex { group, gix ->
  def builders = [:]
  group.eachWithIndex { conf, cdx ->
    def oss = conf["oss"]
    def commit = conf["commit"].toString()
    def ref = conf["ref"].toString()
    def profile = conf["txt"].toString()
    def url = conf["url"].toString()
    def uid = "${env.BRANCH_NAME}_${env.BUILD_NUMBER}_${gix}_${cdx}"

    builders["${oss} - Stage ${gix} - Build ${cdx}"] = {
      node(oss) {
        stage("${oss} - Stage ${gix} - Build ${cdx}"){
          echo ref
          echo profile
          def curdir = pwd().toString()
          def build_folder = "${curdir}/package_repo/${uid}".toString()
          if(oss == "Windows"){
            build_folder = win_tmp_path + "/${uid}"
          }

          def env = []
          if(oss == "Macos"){
              env = ['PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin']
          }
          withEnv(env) {
                Process(build_folder, commit, url, profile, ref, arti_instance, credential, repo_name)
          }
        }
      }
    }
  }
  parallel builders
}

