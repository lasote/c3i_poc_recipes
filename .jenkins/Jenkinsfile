def arti_instance = "https://conan.jfrog.io/conan"
def credential = "c3i_on_artifactory"
def artifactory_name = "ArtifactoryConan"
def core_repo = "https://github.com/lasote/c3i_core.git"

def win_tmp_path = "C:/J/c3ipr"
def json_file_path = 'c3i_configs.json'
def repo_name = "c3i_${env.BRANCH_NAME}_${env.BUILD_NUMBER}".toString()
def the_json
def current_branch = "${env.BRANCH_NAME}"


def Run(command, sudo=false, returnStatus=false){
    def ret
    if(!isUnix()){
      ret = bat script: command, returnStatus: returnStatus
    }
    else{
      if(sudo){
        command = "sudo " + command
      }
      ret = sh script: command, returnStatus: returnStatus
    }
    return ret
}

def Process(build_folder, commit, url, profile, ref, arti_instance, credential, repo_name){
    //Run("pip install virtualenv", true)

     Run("pip install conan --upgrade")
     echo "BUILD FOLDER: ${build_folder}"
     dir(build_folder){
        if(!isUnix()){
           Run("git config --global core.autocrlf false")
        }
        checkout([$class: 'GitSCM', branches: [[name: commit ]], userRemoteConfigs: [[url: url]]])
        writeFile file: "${build_folder}/_profile.txt", text: profile
        def server = Artifactory.newServer url: arti_instance, credentialsId: credential
        def client = Artifactory.newConanClient(userHome: build_folder)
        def remoteName = client.remote.add server: server, repo: repo_name

        withEnv(["CONAN_USER_HOME=${build_folder}"]){
            def install = "conan install ${ref} -pr ${build_folder}/_profile.txt --build never -r ${remoteName}".toString()
            def ret = Run(install, false, true)
            if(ret != 0){
                def create = "conan create ${build_folder} ${ref} -pr ${build_folder}/_profile.txt".toString()
                ret = Run(create, false, true)
                if(ret == 6){
                  echo "Skipping configuration!"
                }
                else if(ret == 0){
                  client.run(command: "remote list")
                  def b = client.run(command: "upload ${ref} -r '${remoteName}' --all -c".toString())
                  server.publishBuildInfo b
                }
                else{
                    throw new Exception("Conan create error ${ret}")
                }
            }
            else{
                echo "Skipping, binary already found in the repository!"
            }
        }
     }

}
if(current_branch == "master"){
    node("Linux"){
        stage("Merge PR packages"){
            def commit_message = sh(returnStdout: true, script: 'git show -s --format="format:%s"').trim()
            dir(".c3_core") {
               git branch: 'master', url: core_repo
               Run("pip install -r c3i/requirements.txt")
               withCredentials([usernameColonPassword(credentialsId: credential, variable: 'USER_PASS')]) {
                  sh script: "./c3i/util/merge_pr.sh ${arti_instance} $USER_PASS "${commit_message}"
               }
            }
        }
    }
}
else{
    node("Linux"){
       stage("Calculate builds: "){
          echo "${env.BRANCH_NAME}"
          def basedir = pwd()
          dir(".c3_core") {
             git branch: 'master', url: core_repo
             Run("pip install -r c3i/requirements.txt")
             sh(script: "./c3i/pull_request/launch.sh ${basedir} ${json_file_path}")
             the_json = readJSON file: json_file_path
          }
       }
       stage("Create Build Artifactory: ${repo_name}"){
          withCredentials([usernameColonPassword(credentialsId: credential, variable: 'USER_PASS')]) {
              sh script: "./c3i/util/create_repo.sh ${arti_instance} ${repo_name} $USER_PASS"
          }
       }
    }


    the_json["stages"].eachWithIndex { group, gix ->
      def builders = [:]
      group.eachWithIndex { conf, cdx ->
        def oss = conf["oss"]
        def commit = conf["commit"].toString()
        def ref = conf["ref"].toString()
        def profile = conf["txt"].toString()
        def url = conf["url"].toString()
        def uid = "${env.BRANCH_NAME}_${env.BUILD_NUMBER}_${gix}_${cdx}"

        builders["${oss} - Stage ${gix} - Build ${cdx}"] = {
          node(oss) {
            stage("${oss} - Provision"){
                if(oss == "c3i-docker"){ // REMOVE THIS WHEN THE IMAGES ARE CORRECT
                    sh 'docker version'
                    sh 'python3 -V'
                    sh 'apt-get update'
                    sh 'apt-get install -y python3-pip cmake'
                    sh 'pip3 install --upgrade pip'
                    sh 'pip3 install conan-package-tools'
                    sh 'pip3 install virtualenv'
                    sh 'conan -v'
                }
                else if(oss == "Macos"){
                    sh 'pip install virtualenv --user'
                }
                else if(oss == "Windows"){
                    bat 'python -m pip install --upgrade pip'
                    bat 'pip install virtualenv'
                }

            }
            stage("${oss} - Stage ${gix} - Build ${cdx}"){
              echo ref
              echo profile
              def curdir = pwd().toString()
              def build_folder = "${curdir}/package_repo/${uid}".toString()
              if(oss == "Windows"){
                build_folder = win_tmp_path + "/${uid}"
              }

              def env = []
              if(oss == "Macos"){
                  env = ['PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin']
              }
              withEnv(env) {
                if(oss != "c3i-docker"){
                    withPythonEnv('python'){
                        Process(build_folder, commit, url, profile, ref, arti_instance, credential, repo_name)
                    }
                }
                else{
                    Process(build_folder, commit, url, profile, ref, arti_instance, credential, repo_name)
                }
              }
            }
          }
        }
      }
      parallel builders
    }
}
